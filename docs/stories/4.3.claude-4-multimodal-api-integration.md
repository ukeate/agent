# Story 4.3: Claude 4多模态API集成

## Status
Draft

<!--  -->
## Story
**As a** AI系统学习者,
**I want** 集成Claude 4多模态API来处理图像、文档和视频内容,
**so that** 我可以学习和掌握多模态AI技术，实现文本、图像、文档等多种内容类型的理解和处理能力

## Acceptance Criteria
1. 集成Claude 4多模态API，支持图像、文档和视频内容处理
2. 实现多模态内容上传和预处理管道
3. 支持图像理解、文档解析和视频分析功能
4. 实现多模态内容的结构化数据提取
5. 建立多模态处理的错误处理和回退机制
6. 实现多模态处理结果的缓存和存储
7. 创建多模态处理的监控和日志系统
8. 提供多模态处理能力的API接口

## Tasks / Subtasks
- [ ] Claude 4多模态API客户端实现 (AC: 1)
  - [ ] 创建Claude 4 API客户端配置和认证
  - [ ] 实现图像内容发送和响应处理
  - [ ] 实现文档内容发送和响应处理
  - [ ] 实现视频内容发送和响应处理
  - [ ] 添加API调用的重试和错误处理机制
- [ ] 多模态内容上传管道 (AC: 2)
  - [ ] 实现文件上传和验证功能
  - [ ] 创建支持的文件格式检查
  - [ ] 实现文件大小和安全检查
  - [ ] 创建文件预处理和格式转换
- [ ] 多模态处理引擎 (AC: 3)
  - [ ] 实现图像理解功能（物体识别、场景理解、OCR）
  - [ ] 实现文档解析功能（PDF、Word、Excel解析）
  - [ ] 实现视频分析功能（关键帧提取、内容理解）
  - [ ] 创建处理结果的标准化格式
- [ ] 结构化数据提取 (AC: 4)
  - [ ] 实现从图像中提取结构化信息
  - [ ] 实现从文档中提取结构化信息
  - [ ] 实现从视频中提取结构化信息
  - [ ] 创建提取结果的验证和清理逻辑
- [ ] 错误处理和回退机制 (AC: 5)
  - [ ] 实现API限制和配额管理
  - [ ] 创建处理失败的回退策略
  - [ ] 实现超时和重试机制
  - [ ] 添加错误分类和处理逻辑
- [ ] 缓存和存储系统 (AC: 6)
  - [ ] 实现处理结果的Redis缓存
  - [ ] 创建数据库存储模式
  - [ ] 实现缓存失效和更新策略
  - [ ] 添加存储空间管理功能
- [ ] 监控和日志系统 (AC: 7)
  - [ ] 实现多模态处理的性能监控
  - [ ] 创建处理过程的详细日志
  - [ ] 实现处理成功率和延迟统计
  - [ ] 添加异常情况的告警机制
- [ ] API接口实现 (AC: 8)
  - [ ] 创建多模态内容处理的REST API
  - [ ] 实现批量处理API接口
  - [ ] 创建处理状态查询接口
  - [ ] 实现处理历史和结果查询接口

## Dev Notes

### Previous Story Insights
基于Story 4.2已完成的向量索引高级功能：
- 已实现多种向量索引类型（HNSW、IVF、LSH等）
- 建立了完善的向量搜索和优化机制
- 具备了混合搜索能力（语义+关键词）
- 已实现多模态向量搜索的基础架构
- 可以复用现有的向量存储和检索能力

现在需要在此基础上集成Claude 4多模态API，实现真正的多模态内容理解和处理。

### Tech Stack Context
[Source: docs/architecture/tech-stack.md#ai-integration]
- **Backend Framework**: FastAPI 0.116.1+ (异步API框架)
- **LLM Provider**: OpenAI API v1 (需要扩展支持Claude API)
- **Cache**: Redis 7.2+ (处理结果缓存)
- **Database**: PostgreSQL 15+ (结构化数据存储)
- **File Storage**: 本地文件系统 (多媒体文件存储)
- **Language**: Python 3.11+ (AI生态系统支持)

### Project Structure Context
[Source: docs/architecture/unified-project-structure.md#ai-modules]
多模态AI集成相关文件位置：
- **Claude客户端**: `apps/api/src/ai/claude/` (新增目录)
  - `client.py` - Claude API客户端
  - `multimodal.py` - 多模态处理器
  - `config.py` - Claude配置管理
- **多模态处理**: `apps/api/src/ai/multimodal/` (新增目录)
  - `processor.py` - 多模态内容处理器
  - `pipeline.py` - 处理管道
  - `extractors.py` - 结构化数据提取器
  - `validators.py` - 内容验证器
- **文件处理**: `apps/api/src/services/file_service.py` (新增)
- **API路由**: `apps/api/src/api/v1/multimodal.py` (新增)
- **数据模型**: `apps/api/src/models/schemas/multimodal.py` (新增)
- **相关测试**: `apps/api/tests/ai/multimodal/` (新增目录)

### External API Integration
[Source: docs/architecture/external-apis.md#claude-api]
需要新增Claude API集成：
- **Base URL**: https://api.anthropic.com/v1
- **Authentication**: API Key (x-api-key header)
- **Rate Limits**: 根据订阅计划限制
- **Key Endpoints**:
  - `POST /messages` - 发送多模态消息
  - `POST /completions` - 文本补全
- **支持格式**: 图像(JPEG, PNG, WebP, GIF)、文档(PDF, TXT)
- **错误处理**: 实现重试机制和降级策略

### Multimodal Processing Architecture
多模态处理架构设计（学习型实现）：

```python
import asyncio
import aiofiles
import hashlib
import mimetypes
from typing import Dict, Any, List, Optional, Union, BinaryIO
from enum import Enum
from dataclasses import dataclass
from pathlib import Path
import json
import logging
from datetime import datetime, timezone
import base64
from PIL import Image
import pytesseract
import cv2
import numpy as np

class ContentType(str, Enum):
    """内容类型枚举"""
    IMAGE = "image"
    DOCUMENT = "document"
    VIDEO = "video"
    AUDIO = "audio"
    TEXT = "text"

class ProcessingStatus(str, Enum):
    """处理状态"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CACHED = "cached"

@dataclass
class MultimodalContent:
    """多模态内容数据类"""
    content_id: str
    content_type: ContentType
    file_path: Optional[str] = None
    file_size: Optional[int] = None
    mime_type: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
@dataclass
class ProcessingResult:
    """处理结果数据类"""
    content_id: str
    status: ProcessingStatus
    extracted_data: Dict[str, Any]
    confidence_score: float
    processing_time: float
    error_message: Optional[str] = None
    created_at: datetime = None

class ClaudeMultimodalClient:
    """Claude多模态API客户端"""
    
    def __init__(self, api_key: str, base_url: str = "https://api.anthropic.com/v1"):
        self.api_key = api_key
        self.base_url = base_url
        self.session = None
        self.rate_limiter = None
        
    async def __aenter__(self):
        import aiohttp
        self.session = aiohttp.ClientSession(
            headers={"x-api-key": self.api_key},
            timeout=aiohttp.ClientTimeout(total=300)  # 5分钟超时
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def process_image(
        self,
        image_data: bytes,
        prompt: str,
        max_tokens: int = 1000
    ) -> Dict[str, Any]:
        """处理图像内容"""
        # 编码图像为base64
        image_b64 = base64.b64encode(image_data).decode('utf-8')
        
        payload = {
            "model": "claude-3-5-sonnet-20241022",
            "max_tokens": max_tokens,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/jpeg",
                                "data": image_b64
                            }
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ]
        }
        
        async with self.session.post(f"{self.base_url}/messages", json=payload) as response:
            if response.status == 200:
                result = await response.json()
                return result
            else:
                error_text = await response.text()
                raise Exception(f"Claude API error: {response.status} - {error_text}")
    
    async def process_document(
        self,
        document_text: str,
        prompt: str,
        max_tokens: int = 1000
    ) -> Dict[str, Any]:
        """处理文档内容"""
        payload = {
            "model": "claude-3-5-sonnet-20241022",
            "max_tokens": max_tokens,
            "messages": [
                {
                    "role": "user",
                    "content": f"{prompt}\n\n文档内容：\n{document_text}"
                }
            ]
        }
        
        async with self.session.post(f"{self.base_url}/messages", json=payload) as response:
            if response.status == 200:
                result = await response.json()
                return result
            else:
                error_text = await response.text()
                raise Exception(f"Claude API error: {response.status} - {error_text}")

class MultimodalProcessor:
    """多模态内容处理器"""
    
    def __init__(self, claude_client: ClaudeMultimodalClient, cache_manager, storage_path: str):
        self.claude = claude_client
        self.cache = cache_manager
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        
        # 支持的文件格式
        self.supported_formats = {
            ContentType.IMAGE: {'.jpg', '.jpeg', '.png', '.webp', '.gif'},
            ContentType.DOCUMENT: {'.pdf', '.txt', '.docx', '.md'},
            ContentType.VIDEO: {'.mp4', '.avi', '.mov', '.mkv'},
            ContentType.AUDIO: {'.mp3', '.wav', '.flac', '.ogg'}
        }
        
    async def process_content(
        self,
        content: MultimodalContent,
        processing_options: Dict[str, Any] = None
    ) -> ProcessingResult:
        """处理多模态内容"""
        start_time = datetime.now(timezone.utc)
        
        try:
            # 检查缓存
            cache_key = f"multimodal:{content.content_id}"
            cached_result = await self.cache.get(cache_key)
            if cached_result:
                logging.info(f"Using cached result for content {content.content_id}")
                return ProcessingResult(**json.loads(cached_result))
            
            # 根据内容类型选择处理方法
            if content.content_type == ContentType.IMAGE:
                result_data = await self._process_image(content, processing_options)
            elif content.content_type == ContentType.DOCUMENT:
                result_data = await self._process_document(content, processing_options)
            elif content.content_type == ContentType.VIDEO:
                result_data = await self._process_video(content, processing_options)
            else:
                raise ValueError(f"Unsupported content type: {content.content_type}")
            
            # 计算处理时间
            processing_time = (datetime.now(timezone.utc) - start_time).total_seconds()
            
            # 创建处理结果
            result = ProcessingResult(
                content_id=content.content_id,
                status=ProcessingStatus.COMPLETED,
                extracted_data=result_data,
                confidence_score=result_data.get('confidence', 0.8),
                processing_time=processing_time,
                created_at=start_time
            )
            
            # 缓存结果
            await self.cache.setex(
                cache_key,
                3600,  # 1小时缓存
                json.dumps(result.__dict__, default=str)
            )
            
            return result
            
        except Exception as e:
            logging.error(f"Error processing content {content.content_id}: {e}")
            processing_time = (datetime.now(timezone.utc) - start_time).total_seconds()
            
            return ProcessingResult(
                content_id=content.content_id,
                status=ProcessingStatus.FAILED,
                extracted_data={},
                confidence_score=0.0,
                processing_time=processing_time,
                error_message=str(e),
                created_at=start_time
            )
    
    async def _process_image(
        self,
        content: MultimodalContent,
        options: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """处理图像内容"""
        # 读取图像文件
        async with aiofiles.open(content.file_path, 'rb') as f:
            image_data = await f.read()
        
        # 基础图像分析提示
        base_prompt = """请分析这张图像并提供以下信息：
1. 图像中的主要对象和场景描述
2. 如果有文字，请提取所有可见的文本内容
3. 图像的整体情感色调或氛围
4. 任何值得注意的细节或特征

请以JSON格式返回结果，包含以下字段：
- description: 图像的详细描述
- objects: 识别到的主要对象列表
- text_content: 提取的文本内容（如果有）
- sentiment: 情感分析（positive/negative/neutral）
- details: 其他重要细节
"""
        
        # 使用Claude处理图像
        claude_result = await self.claude.process_image(image_data, base_prompt)
        
        # 解析Claude的响应
        response_text = claude_result.get('content', [{}])[0].get('text', '')
        
        try:
            # 尝试解析JSON响应
            extracted_data = json.loads(response_text)
        except json.JSONDecodeError:
            # 如果不是JSON，创建结构化数据
            extracted_data = {
                "description": response_text,
                "objects": [],
                "text_content": "",
                "sentiment": "neutral",
                "details": response_text
            }
        
        # 添加技术元数据
        extracted_data.update({
            "file_size": content.file_size,
            "mime_type": content.mime_type,
            "processing_method": "claude_multimodal",
            "model_used": "claude-3-5-sonnet"
        })
        
        return extracted_data
    
    async def _process_document(
        self,
        content: MultimodalContent,
        options: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """处理文档内容"""
        # 提取文档文本
        document_text = await self._extract_document_text(content.file_path)
        
        # 文档分析提示
        analysis_prompt = """请分析这份文档并提供以下信息：
1. 文档的主要主题和内容摘要
2. 关键信息点和重要数据
3. 文档的结构和组织方式
4. 任何表格、图表或特殊格式的内容

请以JSON格式返回结果，包含以下字段：
- summary: 文档摘要
- key_points: 关键信息点列表
- structure: 文档结构描述
- data_elements: 提取的数据元素
- document_type: 推断的文档类型
"""
        
        # 使用Claude处理文档
        claude_result = await self.claude.process_document(document_text, analysis_prompt)
        
        # 解析响应
        response_text = claude_result.get('content', [{}])[0].get('text', '')
        
        try:
            extracted_data = json.loads(response_text)
        except json.JSONDecodeError:
            extracted_data = {
                "summary": response_text,
                "key_points": [],
                "structure": "未知",
                "data_elements": {},
                "document_type": "text"
            }
        
        # 添加技术元数据
        extracted_data.update({
            "text_length": len(document_text),
            "file_size": content.file_size,
            "mime_type": content.mime_type,
            "processing_method": "claude_text_analysis"
        })
        
        return extracted_data
    
    async def _extract_document_text(self, file_path: str) -> str:
        """从文档中提取文本"""
        file_path = Path(file_path)
        suffix = file_path.suffix.lower()
        
        if suffix == '.txt':
            async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                return await f.read()
        elif suffix == '.pdf':
            # 使用PyPDF2或pdfplumber提取PDF文本
            import PyPDF2
            text = ""
            with open(file_path, 'rb') as f:
                pdf_reader = PyPDF2.PdfReader(f)
                for page in pdf_reader.pages:
                    text += page.extract_text() + "\n"
            return text
        elif suffix == '.docx':
            # 使用python-docx提取Word文档文本
            from docx import Document
            doc = Document(file_path)
            text = ""
            for paragraph in doc.paragraphs:
                text += paragraph.text + "\n"
            return text
        else:
            raise ValueError(f"Unsupported document format: {suffix}")
    
    async def _process_video(
        self,
        content: MultimodalContent,
        options: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """处理视频内容"""
        # 提取关键帧
        frames = await self._extract_video_frames(content.file_path)
        
        extracted_data = {
            "frame_count": len(frames),
            "key_frames": [],
            "overall_analysis": {},
            "processing_method": "frame_extraction_analysis"
        }
        
        # 分析每个关键帧
        for i, frame_data in enumerate(frames[:5]):  # 限制分析前5帧
            frame_prompt = f"分析视频第{i+1}个关键帧，描述场景内容和主要元素。"
            
            try:
                frame_result = await self.claude.process_image(frame_data, frame_prompt)
                frame_analysis = frame_result.get('content', [{}])[0].get('text', '')
                
                extracted_data["key_frames"].append({
                    "frame_index": i,
                    "analysis": frame_analysis,
                    "timestamp": i * 2.0  # 假设每2秒一帧
                })
            except Exception as e:
                logging.warning(f"Failed to analyze frame {i}: {e}")
        
        return extracted_data
    
    async def _extract_video_frames(self, video_path: str, max_frames: int = 10) -> List[bytes]:
        """从视频中提取关键帧"""
        import cv2
        
        frames = []
        cap = cv2.VideoCapture(video_path)
        
        try:
            total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            frame_interval = max(1, total_frames // max_frames)
            
            frame_count = 0
            while cap.isOpened() and len(frames) < max_frames:
                ret, frame = cap.read()
                if not ret:
                    break
                
                if frame_count % frame_interval == 0:
                    # 将帧转换为JPEG格式的字节数据
                    _, buffer = cv2.imencode('.jpg', frame)
                    frames.append(buffer.tobytes())
                
                frame_count += 1
        
        finally:
            cap.release()
        
        return frames

class FileUploadService:
    """文件上传服务"""
    
    def __init__(self, upload_path: str, max_file_size: int = 50 * 1024 * 1024):
        self.upload_path = Path(upload_path)
        self.upload_path.mkdir(parents=True, exist_ok=True)
        self.max_file_size = max_file_size
        
    async def save_uploaded_file(
        self,
        file_data: BinaryIO,
        filename: str,
        content_type: str
    ) -> MultimodalContent:
        """保存上传的文件"""
        # 生成唯一的文件ID
        file_hash = hashlib.md5(file_data.read()).hexdigest()
        file_data.seek(0)  # 重置文件指针
        
        # 确定内容类型
        mime_type = mimetypes.guess_type(filename)[0] or content_type
        detected_type = self._detect_content_type(mime_type)
        
        # 生成安全的文件名
        safe_filename = f"{file_hash}_{filename}"
        file_path = self.upload_path / safe_filename
        
        # 保存文件
        async with aiofiles.open(file_path, 'wb') as f:
            content = file_data.read()
            await f.write(content)
        
        return MultimodalContent(
            content_id=file_hash,
            content_type=detected_type,
            file_path=str(file_path),
            file_size=len(content),
            mime_type=mime_type,
            metadata={
                "original_filename": filename,
                "upload_timestamp": datetime.now(timezone.utc).isoformat()
            }
        )
    
    def _detect_content_type(self, mime_type: str) -> ContentType:
        """检测内容类型"""
        if mime_type.startswith('image/'):
            return ContentType.IMAGE
        elif mime_type.startswith('video/'):
            return ContentType.VIDEO
        elif mime_type.startswith('audio/'):
            return ContentType.AUDIO
        elif mime_type in ['application/pdf', 'text/plain', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']:
            return ContentType.DOCUMENT
        else:
            return ContentType.TEXT

class ProcessingPipeline:
    """多模态处理管道"""
    
    def __init__(self, processor: MultimodalProcessor, db_session):
        self.processor = processor
        self.db = db_session
        self.processing_queue = asyncio.Queue()
        self.is_running = False
        
    async def start(self):
        """启动处理管道"""
        self.is_running = True
        await self._process_queue()
    
    async def stop(self):
        """停止处理管道"""
        self.is_running = False
    
    async def submit_for_processing(
        self,
        content: MultimodalContent,
        priority: int = 1
    ) -> str:
        """提交内容进行处理"""
        await self.processing_queue.put({
            "content": content,
            "priority": priority,
            "submitted_at": datetime.now(timezone.utc)
        })
        return content.content_id
    
    async def _process_queue(self):
        """处理队列中的任务"""
        while self.is_running:
            try:
                # 获取待处理任务
                task = await asyncio.wait_for(
                    self.processing_queue.get(),
                    timeout=1.0
                )
                
                # 处理内容
                result = await self.processor.process_content(task["content"])
                
                # 保存结果到数据库
                await self._save_result(result)
                
                logging.info(f"Processed content {task['content'].content_id} - Status: {result.status}")
                
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logging.error(f"Error in processing pipeline: {e}")
    
    async def _save_result(self, result: ProcessingResult):
        """保存处理结果到数据库"""
        # 这里应该实现数据库保存逻辑
        # 例如：await self.db.execute(insert_query, result_data)
        pass
```

### Testing Requirements
[Source: docs/architecture/testing-strategy.md#ai-module-testing]
- **多模态处理测试覆盖率**: ≥85%
- **API集成测试**: 验证Claude API调用的正确性
- **错误处理测试**: 验证各种异常情况的处理
- **性能测试**: 验证多模态处理的响应时间

#### Test File Locations
- **Claude客户端测试**: `apps/api/tests/ai/claude/test_client.py`
- **多模态处理测试**: `apps/api/tests/ai/multimodal/test_processor.py`
- **文件上传测试**: `apps/api/tests/services/test_file_service.py`
- **API路由测试**: `apps/api/tests/api/v1/test_multimodal.py`
- **集成测试**: `apps/api/tests/integration/test_multimodal_pipeline.py`

#### Testing Requirements for This Story
- 验证Claude API的图像、文档和视频处理功能
- 验证文件上传和格式验证功能
- 验证多模态内容的结构化数据提取
- 验证缓存和存储机制
- 验证错误处理和回退机制
- 验证API接口的完整性和性能

## Testing

### Testing Standards
[Source: docs/architecture/testing-strategy.md#backend-testing]
- 使用pytest进行Python后端测试
- 异步测试支持：使用pytest-asyncio
- Mock外部API调用：使用unittest.mock和aioresponses
- 数据库测试：使用测试专用数据库和事务回滚
- 文件处理测试：使用临时文件和清理机制

### Specific Test Scenarios for This Story
- Claude API客户端的正确性和错误处理
- 多模态内容处理的准确性和性能
- 文件上传和验证的安全性
- 缓存机制的有效性
- API接口的完整性

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-16 | 1.0 | Initial story creation for Epic 4 Phase 3.2 multimodal AI integration | Bob (SM) |